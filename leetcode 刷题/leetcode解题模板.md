





### 滑动窗口

滑动窗口：从第一个元素开始滑动窗口并逐个元素地向右滑，并根据问题调整窗口的长度。在某些情况下窗口大小会保持恒定，在其它情况下窗口大小会增大或减小

适用场景：

- 问题的输入是一种线性数据结构，比如链表、数组或字符串
- 要求查找最长/最短的子字符串、子数组或所需的值



### 二指针或迭代器
双指针：两个指针以一前一后的模式在数据结构中迭代，直到一个或两个指针达到某种特定条件。主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针

- 若两个指针指向同一数组，遍历方向相同且不会相交，也称为滑动窗口，经常用于区间搜索
- 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的

适用场景：

- 要处理排序数组（或链接列表）并需要查找满足某些约束的一组元素的问题
- 数组中的元素集是配对、三元组甚至子数组


### 快速和慢速指针或迭代器

使用两个在数组（或序列/链表）中以不同速度移动的指针

适用场景：

- 处理链表或数组中的循环的问题
- 当需要知道特定元素的位置或链表的总长度时



### 合并区间

一种处理重叠区间的有效技术

应用场景：

- 要求得到一个仅含互斥区间的列表
- 重叠区间



### 循环排序



### 原地反转链表

原地反转，使用已有的节点对象且不占用额外的内存。该模式会从一个指向链表头的变量（current）开始一次反转一个节点，然后一个变量（previous）将指向已经处理过的前一个节点。以锁步的方式，在移动到下一个节点之前将其指向前一个节点，可实现对当前节点的反转

类似应用：

- 反转一个子列表
- 反转每个 K 个元素的子列表



### 树的宽度优先搜索

该模式基于宽度优先搜索（BFS）技术，可遍历一个树并使用一个队列来跟踪一个层级的所有节点，之后再跳转到下一个层级。任何涉及到以逐层级方式遍历树的问题都可以使用这种方法有效解决。

Tree BFS 模式的工作方式是：将根节点推至队列，然后连续迭代直到队列为空。在每次迭代中，我们移除队列头部的节点并「访问」该节点。在移除了队列中的每个节点之后，还将其所有子节点插入到队列中。

使用场景：

- 如果被要求用 in-order、pre-order 或 post-order DFS 来遍历一个树
- 如果问题需要搜索其中节点更接近叶节点的东西



### 树的深度优先搜索

深度搜索，可以使用递归（或该迭代方法的技术栈）来在遍历期间保持对所有之前的（父）节点的跟踪





### Two Heaps

在将给定的一组元素分为两部分时，可从获取一部分的最小元素以及另一部分的最大元素入手。

使用两个堆（heap）：一个用于寻找最小元素的 Min Heap 和一个用于寻找最大元素的 Max Heap

先将前一半的数值存储到 Max Heap，这是由于你要寻找前一半中的最大数值。然后再将另一半存储到 Min Heap，因为你要寻找第二半的最小数值。在任何时候，当前数值列表的中间值都可以根据这两个 heap 的顶部元素计算得到

应用场景：

- 在优先级队列、调度等场景中有用
- 需要找到一个集合的最小/最大/中间元素
- 可用于具有二叉树数据结构的问题



### 子集

使用识别子集的模式，找到给定集合的组合或排列问题

### 经过修改的二叉搜索

二叉搜索的使用：只要给定了排序数组、链表或矩阵，并要求寻找一个特定元素，你可以使用的最佳算法就是二叉搜索

对于一个升序的集合，该模式看起来是这样的：

1. 首先，找到起点和终点的中间位置。寻找中间位置的一种简单方法是：middle = (start + end) / 2。但这很有可能造成整数溢出，所以推荐你这样表示中间位置：middle = start + (end -start) / 2。
2. 如果键值（key）等于中间索引处的值，那么返回这个中间位置。
3. 如果键值不等于中间索引处的值：
4. 检查 key < arr[middle] 是否成立。如果成立，将搜索约简到 end = middle - 15．检查 key > arr[middle] 是否成立。如果成立，将搜索约简到 end = middle + 1



### 前K个元素

要求我们找到一个给定集合中前面的/最小的/最常出现的 K 的元素的问题都在这一模式的范围内

跟踪 K 个元素的最佳的数据结构是 Heap。这一模式会使用 Heap 来求解多个一次性处理一个给定元素集中 K 个元素的问题。该模式是这样工作的：

1.  根据问题的不同，将 K 个元素插入到 min-heap 或 max-heap 中
2. 迭代处理剩余的数，如果你找到一个比 heap 中数更大的数，那么就移除那个数并插入这个更大的数

应用场景：

- 被要求寻找一个给定集合中前面的/最小的/最常出现的 K 的元素
- 被要求对一个数值进行排序以找到一个确定元素



### K路合并

求解涉及一组经过排序的数组的问题，当你被给出了 K 个经过排序的数组时，你可以使用 Heap 来有效地执行所有数组的所有元素的排序遍历。你可以将每个数组的最小元素推送至 Min Heap 以获得整体最小值。在获得了整体最小值后，将来自同一个数组的下一个元素推送至 heap。然后，重复这一过程以得到所有元素的排序遍历结果

1. 将每个数组的第一个元素插入 Min Heap
2. 之后，从该 Heap 取出最小（顶部的）元素，将其加入到合并的列表。
3. 在从 Heap 移除了最小的元素之后，将同一列表的下一个元素插入该 Heap
4. 重复步骤 2 和 3，以排序的顺序填充合并的列表

应用场景：

1. 具有排序数组、列表或矩阵的问题
2. 如果问题要求你合并排序的列表，找到一个排序列表中的最小元素



### 拓扑排序

可用于寻找互相依赖的元素的线性顺序，比如，如果事件 B 依赖于事件 A，那么 A 在拓扑排序时位于 B 之前

1. 初始化。a）使用 HashMap 将图（graph）存储到邻接的列表中；b）为了查找所有源，使用 HashMap 记录 in-degree 的数量
2. 构建图并找到所有顶点的 in-degree。a）根据输入构建图并填充 in-degree HashMap
3. 寻找所有的源。a）所有 in-degree 为 0 的顶点都是源，并会被存入一个队列
4. 排序。a）对于每个源，执行以下操作：i）将其加入到排序的列表；ii）根据图获取其所有子节点；iii）将每个子节点的 in-degree 减少 1；iv）如果一个子节点的 in-degree 变为 0，将其加入到源队列。b）重复 (a)，直到源队列为空

如何识别拓扑排序模式：

- 处理无向有环图的问题
- 如果你被要求以排序顺序更新所有对象
- 如果你有一类遵循特定顺序的对象





