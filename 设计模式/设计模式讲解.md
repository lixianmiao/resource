# 软件设计模式


![img](.\.assert\图片 9.png)



## 设计模式分类


### 创建型模式

特点：描述怎样创建对象，提供创建对象的机制，将对象的创建与使用分离，能提升已有代码的灵活性和可复用性

创建型模式：这类模式主要关注对象的创建过程，如何以最小的代价创建对象，并实现对象的复用。常见的创建型模式包括：

- 单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。
- 工厂模式（Factory）：封装对象的创建过程，使得代码更加灵活和可维护。
- 原型模式（Prototype）：通过复制现有对象来创建新对象。
- 建造者模式（Builder）：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
- 抽象工厂模式（Abstract Factory）等。

#### 单例模式

示例：一个简单的单例模式的实现。

```cpp
#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance; // 静态实例
    static std::mutex mtx;      // 互斥锁以确保线程安全

    // 私有构造函数
    Singleton() {
        std::cout << "Singleton 初始化" << std::endl;
    }

public:
    // 删除拷贝构造函数和赋值操作符，防止复制
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // 获取唯一实例的静态方法
    static Singleton* getInstance() {
        if (instance == nullptr) {
            std::lock_guard<std::mutex> lock(mtx); // 确保线程安全
            if (instance == nullptr) { // 再次检查空指针
                instance = new Singleton();
            }
        }
        return instance;
    }

    void showMessage() {
        std::cout << "Hello from Singleton!" << std::endl;
    }
};

// 初始化静态成员
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;

// 客户端代码
int main() {
    // 获取单例实例并调用方法
    Singleton::getInstance()->showMessage();
    return 0;
}
```

说明

1. 私有构造函数：`Singleton()` 是私有的，防止外部实例化。
2. 静态成员变量：`instance` 是一个指向唯一实例的指针，最开始设为 `nullptr`。
3. 静态方法：`getInstance()` 方法用于获取单例实例。在首次调用时，会创建实例并返回。
4. 线程安全：使用 `std::mutex` 和 `std::lock_guard` 确保在多线程环境中安全地创建实例。
5. 拷贝控制：拷贝构造函数和赋值操作符被删除，防止复制。

优点

- 唯一性：确保类只有一个实例。
- 全局访问：通过静态方法获得全局唯一的实例，便于管理。
- 延迟初始化：只有在首次调用时才创建实例，有助于节省资源。

适用场景

- 当系统需要对某些资源进行全局控制时（例如，数据库连接、线程池）。
- 当类的实例需要限制为一个时。
- 当需要确保某种全局状态的一致性时。


#### 工厂模式

示例：一个简单的图形工厂，根据不同的类型创建不同的图形（如圆形和矩形）

```cpp
#include <iostream>
#include <memory>

// 产品接口
class Shape {
public:
    virtual void draw() = 0; // 绘制图形
    virtual ~Shape() = default;
};

// 具体产品：圆形
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "绘制圆形" << std::endl;
    }
};

// 具体产品：矩形
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "绘制矩形" << std::endl;
    }
};

// 工厂接口
class ShapeFactory {
public:
    virtual std::unique_ptr<Shape> createShape() = 0; // 创建产品方法
    virtual ~ShapeFactory() = default;
};

// 具体工厂：创建圆形的工厂
class CircleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Circle>();
    }
};

// 具体工厂：创建矩形的工厂
class RectangleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Rectangle>();
    }
};

// 客户端代码
int main() {
    //
    std::unique_ptr<ShapeFactory> circleFactory = std::make_unique<CircleFactory>();
    std::unique_ptr<Shape> circle = circleFactory->createShape();
    circle->draw();

    std::unique_ptr<ShapeFactory> rectangleFactory = std::make_unique<RectangleFactory>();
    std::unique_ptr<Shape> rectangle = rectangleFactory->createShape();
    rectangle->draw();

    return 0;
}
```

说明

1. 产品接口：`Shape` 定义了一个抽象方法 `draw`，所有具体产品都要实现这个方法。
2. 具体产品：`Circle` 和 `Rectangle` 实现了 `Shape` 接口，并提供了相应的 `draw` 方法。
3. 工厂接口：`ShapeFactory` 定义了一个 `createShape` 方法，用于创建 `Shape` 对象。
4. 具体工厂：`CircleFactory` 和 `RectangleFactory` 实现了 `ShapeFactory` 接口，负责创建具体的图形对象。
5. 客户端：在 `main` 函数中，创建不同的工厂，并通过工厂生成具体的产品对象，最后调用 `draw` 方法绘制图形。

优点

- 解耦：将对象的创建与使用分离，降低了系统的耦合度。
- 易于扩展：添加新产品只需新增产品类及对应的工厂，不需要修改现有代码。
- 集中管理：可以在工厂中集中处理产品的创建逻辑。

适用场景

- 当系统需要独立于其创建、组合和表示的对象结构时。
- 当需要使用一个共同的接口来创建不同类型的对象时。
- 当要通过子类来决定实例化哪个类时。


#### 抽象工厂

示例：一个使用抽象工厂模式的示例，展示如何创建不同类型的车辆

```cpp
#include <iostream>
#include <string>

// 抽象产品接口
class Car {
public:
    virtual void drive() const = 0;
};

class Bike {
public:
    virtual void ride() const = 0;
};

// 具体产品
class Toyota : public Car {
public:
    void drive() const override {
        std::cout << "Driving a Toyota" << std::endl;
    }
};

class Honda : public Car {
public:
    void drive() const override {
        std::cout << "Driving a Honda" << std::endl;
    }
};

class MountainBike : public Bike {
public:
    void ride() const override {
        std::cout << "Riding a Mountain Bike" << std::endl;
    }
};

class RoadBike : public Bike {
public:
    void ride() const override {
        std::cout << "Riding a Road Bike" << std::endl;
    }
};


// 抽象工厂
class VehicleFactory {
public:
    virtual Car* createCar() const = 0;
    virtual Bike* createBike() const = 0;
};

// 具体工厂
class ToyotaFactory : public VehicleFactory {
public:
    Car* createCar() const override {
        return new Toyota();
    }
    
    Bike* createBike() const override {
        return new MountainBike();
    }
};

class HondaFactory : public VehicleFactory {
public:
    Car* createCar() const override {
        return new Honda();
    }
    
    Bike* createBike() const override {
        return new RoadBike();
    }
};

// 客户端代码
int main() {
    VehicleFactory* factory = new ToyotaFactory();
    
    Car* car = factory->createCar();
    Bike* bike = factory->createBike();
    
    car->drive();
    bike->ride();
    
    delete car;
    delete bike;
    delete factory;

    factory = new HondaFactory();
    
    car = factory->createCar();
    bike = factory->createBike();
    
    car->drive();
    bike->ride();
    
    delete car;
    delete bike;
    delete factory;

    return 0;
}
```

说明

1. 抽象产品 (`Car` 和 `Bike`)：定义了车辆的接口。
2. 具体产品 (`Toyota`, `Honda`, `MountainBike`, `RoadBike`)：实现了抽象产品的具体类。
3. 抽象工厂 (`VehicleFactory`)：定义了创建车辆和自行车的抽象方法。
4. 具体工厂 (`ToyotaFactory`, `HondaFactory`)：具体实现了 `VehicleFactory` 接口，创建相关的产品。
5. 客户端：通过工厂生成产品，无需直接依赖于具体类。

优点

- 易于扩展：可以添加新的产品系列而不需要修改现有代码。
- 解耦：客户端代码与具体产品解耦，便于模块化和管理。
- 一致性：通过确保产品的创建和组合，不同产品之间可以保持一致。

适用场景

- 当系统需要独立于其产品的创建、组合和表示时。
- 当系统提供一个产品类的库，而不需要暴露它的实现细节时。
- 当客户不需要知道产品创建的具体细节时，可以将产品创建过程隐藏在工厂内部。

抽象工厂模式通常用于构建具有丰富产品族的应用，能够更好地管理对象的创建和组合。

#### 原型模式

示例：一个使用原型模式的简单示例，展示如何使用原型模式复制对象

```cpp
#include <iostream>
#include <string>

// 原型接口
class Prototype {
public:
    virtual ~Prototype() {}
    virtual Prototype* clone() const = 0;
};

// 具体原型
class ConcretePrototype : public Prototype {
public:
    ConcretePrototype(const std::string& name) : name(name) {}
    
    // 重写克隆方法
    Prototype* clone() const override {
        return new ConcretePrototype(*this);
    }
    
    void show() const {
        std::cout << "ConcretePrototype name: " << name << std::endl;
    }
    
private:
    std::string name;
};

// 客户端代码
int main() {
    // 创建一个具体原型对象
    ConcretePrototype* original = new ConcretePrototype("Original");
    original->show();

    // 使用原型进行复制
    ConcretePrototype* clone = static_cast<ConcretePrototype*>(original->clone());
    clone->show();

    // 清理内存
    delete original;
    delete clone;

    return 0;
}
```

说明

1. 原型接口 (`Prototype`)：定义一个 `clone` 方法，用于复制对象。
2. 具体原型 (`ConcretePrototype`)：实现了 `clone` 方法，可以复制自身的实例。
3. 客户端：创建了一个原型实例，并通过原型模式复制这个对象。

优点

- 避免构造成本：不必通过构造函数初始化，可以快速复制已有对象。
- 运行时创建对象：能够在运行时动态创建和修改对象。
- 简化创建过程：适合创建复杂对象，减少了对象创建的复杂度。

适用场景

- 当一个类的实例化过程比较复杂，但你希望简单地创建多个相似对象时。
- 当对象的状态需要被复制时。
- 当你希望在某些情况下避免使用构造器时，可以考虑使用原型模式。

原型模式在某些情况下能够显著提高性能，尤其在频繁创建对象的场景中，具有很高的实用价值。

#### 建造者

示例：一个使用建造者模式的简单示例，构建一个`Car`（汽车）对象。

```cpp
#include <iostream>
#include <string>

// 产品类
class Car {
public:
    void setEngine(const std::string& engine) {
        this->engine = engine;
    }
    void setWheels(int wheels) {
        this->wheels = wheels;
    }
    void setColor(const std::string& color) {
        this->color = color;
    }
    void show() const {
        std::cout << "Car with engine: " << engine
                  << ", wheels: " << wheels
                  << ", color: " << color << std::endl;
    }
private:
    std::string engine;
    int wheels;
    std::string color;
};

// 建造者接口
class CarBuilder {
public:
    virtual ~CarBuilder() {}
    virtual void buildEngine() = 0;
    virtual void buildWheels() = 0;
    virtual void buildColor() = 0;
    virtual Car* getCar() = 0;
};

// 具体建造者
class SportsCarBuilder : public CarBuilder {
public:
    SportsCarBuilder() { car = new Car(); }
    void buildEngine() override {
        car->setEngine("V8 Engine");
    }
    void buildWheels() override {
        car->setWheels(4);
    }
    void buildColor() override {
        car->setColor("Red");
    }
    Car* getCar() override {
        return car;
    }
private:
    Car* car;
};

// 指挥者
class CarDirector {
public:
    CarDirector(CarBuilder* builder) : builder(builder) {}

    void construct() {
        builder->buildEngine();
        builder->buildWheels();
        builder->buildColor();
    }
private:
    CarBuilder* builder;
};

// 客户端代码
int main() {
    SportsCarBuilder* sportsCarBuilder = new SportsCarBuilder();
    CarDirector director(sportsCarBuilder);

    director.construct();
    Car* car = sportsCarBuilder->getCar();
    car->show();

    delete car;
    delete sportsCarBuilder;

    return 0;
}
```

说明

1. 产品类 `Car`：表示最终构建的对象，具有各种属性和显示功能。
2. 建造者接口 (`CarBuilder`)：定义了构建汽车的基本方法。
3. 具体建造者 (`SportsCarBuilder`)：实现了建造者接口，负责具体的构建实现。
4. 指挥者 (`CarDirector`)：使用建造者来构建具体产品的顺序。
5. 客户端：创建建造者和指挥者的实例，调用构建方法并展示结果。

优点

- 分离复杂逻辑：将对象的构建逻辑与表现逻辑分离，代码更清晰。
- 灵活性：可以生成不同类型的对象，甚至可以在运行时选择不同的建造者。
- 易于扩展：如果想要增加新的产品类型，只需增加一个新的建造者，无需修改现有代码。

建造者模式在实际开发中非常常用，特别适合需要构建复杂对象的场景，比如构建UI组件、配置文件或复杂的数据结构。



### 结构性模式

结构型模式：这类模式关注类或对象的组合，如何将类或对象组合成更大的结构来构建软件系统。常见的结构型模式包括：

- 适配器模式（Adapter）：将一个类的接口转换成客户端所期望的另一种接口，从而使原本由于接口不兼容而无法协同工作的类能够一起工作。
- 装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更为灵活。
- 桥接模式（Bridge）：将抽象与实现解耦，使它们可以独立变化。
- 组合模式（Composite）等。

#### 适配器

示例：如何将一个旧的电源接口适配为新的接口

```cpp
#include <iostream>

// 目标接口
class Target {
public:
    virtual void request() const {
        std::cout << "Target: Handling request." << std::endl;
    }
};

// 被适配类
class Adaptee {
public:
    void specificRequest() const {
        std::cout << "Adaptee: Specific request." << std::endl;
    }
};

// 适配器
class Adapter : public Target {
private:
    Adaptee* adaptee;

public:
    Adapter(Adaptee* a) : adaptee(a) {}

    void request() const override {
        std::cout << "Adapter: Adapting request." << std::endl;
        adaptee->specificRequest();
    }
};

// 客户端代码
int main() {
    Adaptee* adaptee = new Adaptee();
    Target* adapter = new Adapter(adaptee);

    // 客户端通过适配器进行请求
    adapter->request();

    // 清理内存
    delete adaptee;
    delete adapter;

    return 0;
}
```

说明

1. 目标接口 (`Target`)：客户端使用的接口，定义了 `request` 方法。
2. 被适配类 (`Adaptee`)：有一个 `specificRequest` 方法，与目标接口不兼容。
3. 适配器 (`Adapter`)：继承自 `Target`，重写 `request` 方法，在其中调用 `Adaptee` 的 `specificRequest`。
4. 客户端：通过 `Adapter` 与 `Adaptee` 进行交互，隐藏了细节。

优点

- 解耦：将客户端与被适配的类解耦，便于模块化。
- 灵活性：可以通过适配器轻松替换或改变被适配的类。
- 复用性：现有类可以不修改地被重新使用。

适用场景

- 当你希望使用一些已经存在的类，但它们的接口不符合你的需求时。
- 当需要在不同接口之间进行互操作时。
- 当想要创建一个可复用的类，它可以与多个不相关的类一起工作时。

适配器模式在需要兼容旧代码或实现不一致接口时，非常有用，使得不同的系统或组件能够协同工作。

#### 桥接

桥接模式是一种结构型设计模式，通过将抽象部分与实现部分分离，使得两者可以独立变化。这样可以避免在每个实现变化时都去修改所有的抽象类，提升了系统的灵活性和可扩展性。

主要组成部分

1. 抽象类（Abstraction）：定义高层接口，持有对实现类的引用。
2. 修正抽象类（Refined Abstraction）：扩展抽象类，实现其方法。
3. 实现类接口（Implementor）：定义实现的接口，但不一定是完整的实现。
4. 具体实现类（Concrete Implementor）：实现了实现类接口的具体类。

例子

以下是一个使用桥接模式的示例，展示如何将不同类型的图形与不同的颜色进行桥接。

示例：

```cpp
#include <iostream>

// 实现类接口
class Color {
public:
    virtual void fill() const = 0;
};

// 具体实现类
class Red : public Color {
public:
    void fill() const override {
        std::cout << "Filling with red color." << std::endl;
    }
};

class Green : public Color {
public:
    void fill() const override {
        std::cout << "Filling with green color." << std::endl;
    }
};

// 抽象类
class Shape {
protected:
    Color* color; // 持有实现类的引用

public:
    Shape(Color* c) : color(c) {}
    virtual void draw() const = 0;
};

// 修正抽象类
class Circle : public Shape {
public:
    Circle(Color* c) : Shape(c) {}

    void draw() const override {
        std::cout << "Drawing Circle." << std::endl;
        color->fill(); // 通过实现类调用具体实现
    }
};

class Square : public Shape {
public:
    Square(Color* c) : Shape(c) {}

    void draw() const override {
        std::cout << "Drawing Square." << std::endl;
        color->fill();
    }
};

// 客户端代码
int main() {
    Color* red = new Red();
    Color* green = new Green();

    Shape* circle = new Circle(red);
    Shape* square = new Square(green);

    circle->draw(); // Drawing Circle. Filling with red color.
    square->draw(); // Drawing Square. Filling with green color.

    // 清理内存
    delete circle;
    delete square;
    delete red;
    delete green;

    return 0;
}
```

说明

1. 实现类接口 (`Color`)：定义了 `fill` 方法，表示颜色的填充方式。
2. 具体实现类 (`Red`, `Green`)：实现了 `Color` 接口，提供具体的颜色填充逻辑。
3. 抽象类 (`Shape`)：定义了 `draw` 方法，持有颜色对象的引用。抽象类通过颜色对象调用颜色填充。
4. 修正抽象类 (`Circle`, `Square`)：具体形状类，实现了具体的绘制逻辑，并通过颜色对象调用填充方法。
5. 客户端：创建具体的形状和颜色对象，并调用形状的 `draw` 方法。

优点

- 解耦：抽象和实现之间的解耦，改动一方不会影响另一方。
- 灵活性：可以独立增加新的实现类或抽象类，扩展性强。
- 简化代码：减少了子类的数量，避免了笨重的继承结构。

适用场景

- 当一个类有多个可变部分时，使用桥接模式可以避免复杂的继承关系。
- 当需要在多个维度上变化的抽象时，例如图形与颜色的结合。
- 当希望在不影响客户端的情况下扩展系统的功能时。

桥接模式非常适合需要将接口与其实现随意组合的场景，能够有效提高代码的灵活性和可维护性。

#### 组合

组合模式是一种结构性设计模式，它允许将对象组合成树形结构以表示“部分-整体”的层次关系。组合模式能够让客户端以统一的方式对待单个对象和组合对象，使得在树形结构中处理部分和整体变得一致。

主要角色

1. **Component（组件）**：定义了叶子和组合对象的公共接口，可以是抽象类或接口。
2. **Leaf（叶子）**：代表组合中的叶子节点，叶子对象没有子节点。
3. **Composite（组合）**：代表可以有子节点的节点，组合对象包含子组件，可以是叶子或其他组合。

优点

- **简化客户端代码**：客户端不需要关心组合的复杂性，系统地对待单个对象和组合对象。
- **方便扩展**：可以自由添加叶子和组合，而无需改变现有代码。

示例

以下是一个用 C++ 实现的组合模式的示例，展示文件系统中文件和文件夹的层次结构。

```cpp
#include <iostream>
#include <vector>
#include <memory>

// Component
class FileSystemNode {
public:
    virtual void display(int indent = 0) const = 0;
    virtual ~FileSystemNode() {}
};

// Leaf
class File : public FileSystemNode {
private:
    std::string name;
public:
    File(const std::string& n) : name(n) {}

    void display(int indent = 0) const override {
        std::cout << std::string(indent, ' ') << "File: " << name << std::endl;
    }
};

// Composite
class Directory : public FileSystemNode {
private:
    std::string name;
    std::vector<std::shared_ptr<FileSystemNode>> children;
public:
    Directory(const std::string& n) : name(n) {}

    void add(const std::shared_ptr<FileSystemNode>& node) {
        children.push_back(node);
    }

    void remove(const std::shared_ptr<FileSystemNode>& node) {
        // 简化处理，通常需要实现更复杂的移除逻辑
        children.erase(std::remove(children.begin(), children.end(), node), children.end());
    }

    void display(int indent = 0) const override {
        std::cout << std::string(indent, ' ') << "Directory: " << name << std::endl;
        for (const auto& child : children) {
            child->display(indent + 2);
        }
    }
};

// 示例
int main() {
    auto root = std::make_shared<Directory>("root");
    auto folder1 = std::make_shared<Directory>("folder1");
    auto folder2 = std::make_shared<Directory>("folder2");

    root->add(folder1);
    root->add(folder2);
    folder1->add(std::make_shared<File>("file1.txt"));
    folder1->add(std::make_shared<File>("file2.txt"));
    folder2->add(std::make_shared<File>("file3.txt"));

    root->display();

    return 0;
}
```

输出结果

```
Directory: root
  Directory: folder1
    File: file1.txt
    File: file2.txt
  Directory: folder2
    File: file3.txt
```

#### 装饰

装饰模式（Decorator Pattern）

装饰模式是一种结构型设计模式，通过动态地将额外的职责附加到对象上，使得功能可以在运行时进行扩展。它在不改变对象自身的情况下，为对象添加新的功能，遵循了开闭原则（对扩展开放，对修改关闭）。

主要组成部分

1. 抽象构件（Component）：定义一个接口，用于定义被装饰的对象和装饰者的共同接口。
2. 具体构件（Concrete Component）：实现了抽象构件接口的具体对象。
3. 装饰者（Decorator）：持有一个构件对象的引用，并且实现了抽象构件的接口，以便扩展功能。
4. 具体装饰者（Concrete Decorator）：扩展装饰者，添加具体的功能。

例子

以下是一个使用装饰模式的示例，展示如何给一个咖啡饮料添加不同的配料。

示例：

```cpp
#include <iostream>
#include <string>

// 抽象构件
class Beverage {
public:
    virtual std::string getDescription() const = 0; // 获取饮料描述
    virtual double cost() const = 0; // 获取饮料价格
};

// 具体构件
class Coffee : public Beverage {
public:
    std::string getDescription() const override {
        return "Coffee";
    }

    double cost() const override {
        return 2.0; // 基本价格
    }
};

// 装饰者
class CondimentDecorator : public Beverage {
protected:
    Beverage* beverage; // 持有被装饰的饮料

public:
    CondimentDecorator(Beverage* b) : beverage(b) {}
};

// 具体装饰者
class Milk : public CondimentDecorator {
public:
    Milk(Beverage* b) : CondimentDecorator(b) {}

    std::string getDescription() const override {
        return beverage->getDescription() + ", Milk";
    }

    double cost() const override {
        return beverage->cost() + 0.5; // 加价
    }
};

class Sugar : public CondimentDecorator {
public:
    Sugar(Beverage* b) : CondimentDecorator(b) {}

    std::string getDescription() const override {
        return beverage->getDescription() + ", Sugar";
    }

    double cost() const override {
        return beverage->cost() + 0.2; // 加价
    }
};

// 客户端代码
int main() {
    Beverage* coffee = new Coffee();
    std::cout << coffee->getDescription() << " $" << coffee->cost() << std::endl;

    // 添加牛奶
    coffee = new Milk(coffee);
    std::cout << coffee->getDescription() << " $" << coffee->cost() << std::endl;

    // 添加糖
    coffee = new Sugar(coffee);
    std::cout << coffee->getDescription() << " $" << coffee->cost() << std::endl;

    // 清理内存
    delete coffee; // 需要注意，实际应用中应使用智能指针

    return 0;
}
```

说明

1. 抽象构件 (`Beverage`)：定义了饮料的接口，提供获取描述和售价的方法。
2. 具体构件 (`Coffee`)：实现了 `Beverage` 接口，提供了基本咖啡的描述和价格。
3. 装饰者 (`CondimentDecorator`)：扩展了 `Beverage` 接口，并持有一个指向 `Beverage` 的引用。
4. 具体装饰者 (`Milk`, `Sugar`)：实现装饰者，覆盖 `getDescription` 和 `cost` 方法，为饮料添加具体的装饰和加价。
5. 客户端：创建基本咖啡对象，随后通过装饰者为咖啡添加牛奶和糖，动态扩展功能。

优点

- 灵活性：可以动态组合多个装饰，而不必创建大量的子类。
- 符合开闭原则：可以使用装饰而不必修改已有类。
- 增强功能：可以在运行时选择装饰，增加了系统的自由度。

适用场景

- 当需要为对象添加职责而又不想通过子类化的方式扩展功能时。
- 当有多个类可以使用同一功能，且这些功能可以在运行时组合时。
- 当希望在对象的行为上加入一些附加功能，却又不愿意修改类的结构时。

装饰模式非常适合需要扩展和增强功能的场景，能够提供更高的灵活性和可维护性。

#### 外观

外观模式是一种结构型设计模式，它为复杂子系统提供一个简单的接口，封装了系统内部的复杂性。通过外观模式，客户端不需要直接与子系统的各个组件交互，而是通过一个统一的外观类来访问这些功能，从而提高了系统的易用性和维护性。

主要组成部分

1. 外观类（Facade）：提供简化的接口，封装了对复杂子系统的调用。
2. 子系统类（Subsystem Classes）：实现具体的功能，外观类协调这些功能。

例子

以下是一个使用外观模式的示例，展示如何简化对一个音响系统的使用。

示例：

```cpp
#include <iostream>

// 子系统类
class Amplifier {
public:
    void on() {
        std::cout << "Amplifier is on." << std::endl;
    }
    void off() {
        std::cout << "Amplifier is off." << std::endl;
    }
};

class CDPlayer {
public:
    void on() {
        std::cout << "CDPlayer is on." << std::endl;
    }
    void play(const std::string& title) {
        std::cout << "Playing " << title << " from CD." << std::endl;
    }
    void off() {
        std::cout << "CDPlayer is off." << std::endl;
    }
};

class Projector {
public:
    void on() {
        std::cout << "Projector is on." << std::endl;
    }
    void off() {
        std::cout << "Projector is off." << std::endl;
    }
};

// 外观类
class HomeTheaterFacade {
private:
    Amplifier* amplifier;
    CDPlayer* cdPlayer;
    Projector* projector;

public:
    HomeTheaterFacade(Amplifier* amp, CDPlayer* cd, Projector* proj)
        : amplifier(amp), cdPlayer(cd), projector(proj) {}

    void watchMovie(const std::string& movie) {
        std::cout << "Get ready to watch a movie..." << std::endl;
        amplifier->on();
        cdPlayer->on();
        cdPlayer->play(movie);
        projector->on();
    }

    void endMovie() {
        std::cout << "Shutting movie theater down..." << std::endl;
        amplifier->off();
        cdPlayer->off();
        projector->off();
    }
};

// 客户端代码
int main() {
    Amplifier* amp = new Amplifier();
    CDPlayer* cd = new CDPlayer();
    Projector* proj = new Projector();

    HomeTheaterFacade* homeTheater = new HomeTheaterFacade(amp, cd, proj);

    homeTheater->watchMovie("Inception"); // 启动影院
    homeTheater->endMovie(); // 关闭影院

    // 清理内存
    delete homeTheater;
    delete amp;
    delete cd;
    delete proj;

    return 0;
}
```

说明

1. 子系统类：`Amplifier`、`CDPlayer` 和 `Projector` 各自提供了具体的功能方法，比如启动、播放和关闭。
2. 外观类 (`HomeTheaterFacade`)：提供了 `watchMovie` 和 `endMovie` 方法，分别封装了启动影院和关闭影院的流程，简化了客户端代码的复杂性。
3. 客户端：只需要与外观类交互，不必关心底层各个设备的具体操作。

优点

- 简化接口：减少了与复杂子系统交互的复杂性，易于使用。
- 降低耦合：客户端与子系统之间的耦合度降低，便于维护。
- 提高灵活性：可以在不影响客户端代码的情况下对系统内部组件进行修改。

适用场景

- 当系统有多个子系统时，提供一个简化的接口。
- 当需要为复杂的系统提供统一的访问入口。
- 当希望减少与庞大的代码库的依赖，简化用户操作。

外观模式通过提供简单的接口来封装复杂的功能，能够有效地提升代码的可读性和可维护性。

#### 享元

享元模式是一种结构型设计模式，主要用于减少创建对象的数量，从而减少内存使用和提高性能。它通过共享已有的对象来支持大量细粒度的对象，尤其是在需要创建的对象数量大时，可以显著节省资源。

主要组成部分

1. 享元接口（Flyweight Interface）：定义享元对象的公共接口。
2. 具体享元（Concrete Flyweight）：实现享元接口，负责具体的业务逻辑。
3. 享元工厂（Flyweight Factory）：负责创建并管理享元对象，确保共享对象的唯一性。

例子

以下是一个使用享元模式的示例，展示如何在图形编辑应用中共享图形对象（比如圆形），以减少内存占用。

示例：

```cpp
#include <iostream>
#include <map>
#include <string>

// 享元接口
class Shape {
public:
    virtual void draw(int x, int y) = 0; // 绘制图形
    virtual ~Shape() = default;
};

// 具体享元类
class Circle : public Shape {
private:
    std::string color;

public:
    Circle(const std::string& color) : color(color) {}

    void draw(int x, int y) override {
        std::cout << "Circle: Color = " << color << ", X = " << x << ", Y = " << y << std::endl;
    }
};

// 享元工厂
class ShapeFactory {
private:
    std::map<std::string, Shape*> shapes; // Store shared objects

public:
    ~ShapeFactory() {
        for (auto& pair : shapes) {
            delete pair.second;
        }
    }

    Shape* getCircle(const std::string& color) {
        // If same color circle already exists, return it
        if (shapes.find(color) == shapes.end()) {
            shapes[color] = new Circle(color);
        }
        return shapes[color];
    }
};

// 客户端代码
int main() {
    ShapeFactory shapeFactory;

    // 客户端创建多个圆形
    Shape* redCircle = shapeFactory.getCircle("Red");
    redCircle->draw(10, 20);

    Shape* greenCircle = shapeFactory.getCircle("Green");
    greenCircle->draw(30, 40);

    Shape* anotherRedCircle = shapeFactory.getCircle("Red");
    anotherRedCircle->draw(50, 60); // 使用同一个红色圆形实例

    return 0;
}
```

说明

1. 享元接口：`Shape` 定义了方法 `draw()`，支持绘制图形。
2. 具体享元类 (`Circle`)：实现了 `Shape` 接口并存储了颜色属性。不同颜色的圆形共享同一个类实例。
3. 享元工厂 (`ShapeFactory`)：管理 `Circle` 对象的实例化，确保相同颜色的圆形只创建一次，提高了内存使用效率。
4. 客户端：通过工厂方法请求圆形对象，工厂会根据颜色返回共享的圆形实例。

优点

- 内存节省：通过共享相同的对象，显著减少内存占用。
- 提高性能：减少了对象的创建和销毁，对应的性能提升。
- 易于扩展：新的享元类型可以轻松添加，只需实现享元接口。

适用场景

- 当应用程序需要创建大量相似对象时。
- 当对象的状态可以被分为外部状态（不共享）和内部状态（共享）时。
- 当对象的创建成本较高时，可考虑使用享元模式进行共享。

享元模式通过对象的共享来优化资源使用，使软件设计更加高效和灵活。

#### 代理

代理模式是一种结构型设计模式，它为其他对象提供一个代理，以控制对该对象的访问。代理模式通常用于实现懒加载、访问控制、日志记录和权限检查等场景。

主要组成部分

1. 抽象主题（Subject Interface）：定义真实对象和代理对象的共同接口。
2. 真实主题（Real Subject）：定义代理所代表的真实对象，实现了抽象主题接口。
3. 代理（Proxy）：持有对真实主题的引用，并实现了抽象主题接口，控制对真实主题的访问。

例子

以下是一个使用代理模式的示例，展示如何通过代理控制对真实图像加载的访问。

示例：

```cpp
#include <iostream>
#include <string>

// 抽象主题
class Image {
public:
    virtual void display() = 0; // 显示图像
    virtual ~Image() = default;
};

// 真实主题
class RealImage : public Image {
private:
    std::string filename;

public:
    RealImage(const std::string& filename) : filename(filename) {
        loadImageFromDisk(); // 从磁盘加载图像
    }

    void loadImageFromDisk() {
        std::cout << "Loading " << filename << std::endl;
    }

    void display() override {
        std::cout << "Displaying " << filename << std::endl;
    }
};

// 代理
class ProxyImage : public Image {
private:
    RealImage* realImage;
    std::string filename;

public:
    ProxyImage(const std::string& filename) : realImage(nullptr), filename(filename) {}

    ~ProxyImage() {
        delete realImage; // 释放真实图像
    }

    void display() override {
        if (!realImage) {
            realImage = new RealImage(filename); // 延迟加载真实图像
        }
        realImage->display();
    }
};

// 客户端代码
int main() {
    Image* image1 = new ProxyImage("photo1.jpg");
    Image* image2 = new ProxyImage("photo2.jpg");

    // 第一次请求，加载图像
    image1->display();
    std::cout << std::endl;

    // 第二次请求，直接显示图像
    image1->display();
    std::cout << std::endl;

    // 第一次请求另一个图像
    image2->display();

    // 清理内存
    delete image1;
    delete image2;

    return 0;
}
```

说明

1. 抽象主题接口：`Image` 定义了 `display()` 方法，供真实图像和代理实现。
2. 真实主题 (`RealImage`)：实现了 `Image` 接口，并在构造时加载图像（模拟从磁盘读取）。
3. 代理 (`ProxyImage`)：控制访问真实图像，负责延迟加载。只有在调用 `display()` 时才创建 `RealImage` 实例，从而节省资源。
4. 客户端：通过代理对象进行图像显示，当第一次请求时，真实图像才被加载。

优点

- 延迟加载：提高性能，避免不必要的资源消耗。
- 控制访问：可以在代理中添加访问控制、权限检查等逻辑。

### 行为模式

行为型模式（Behavioral Patterns）：这类模式主要关注算法、行为和对象之间的交互与通信。常见的行为型模式包括：

- 观察者模式（Observer）：定义对象之间的一对多依赖关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
- 策略模式（Strategy）：定义一系列的算法，并使它们可以互相替换。
- 中介者模式（Mediator）：通过引入一个中介来减少对象间的直接交互，使程序更加灵活和可维护。
- 状态模式（State）等。

#### 责任链

责任链模式是一种行为型设计模式，它将请求的发送者和接收者解耦，将多个对象连成一条链并沿着这条链传递请求。每个处理者可以选择处理请求或者将请求传递给链中的下一个处理者。

主要组成部分

1. 抽象处理者（Handler）：定义处理请求的接口，并持有对下一个处理者的引用。
2. 具体处理者（Concrete Handler）：实现抽象处理者接口，处理请求。如果不能处理，则将请求转发给下一个处理者。
3. 客户端（Client）：创建责任链，并发送请求。

例子

以下是使用责任链模式的示例，展示如何处理不同级别的审批请求（如经理和总监）。

示例：

```cpp
#include <iostream>
#include <string>

// 抽象处理者
class Approver {
protected:
    Approver* successor;

public:
    Approver() : successor(nullptr) {}

    void setSuccessor(Approver* successor) {
        this->successor = successor;
    }

    virtual void approveRequest(double amount) = 0; // 处理请求
};

// 具体处理者：经理
class Manager : public Approver {
public:
    void approveRequest(double amount) override {
        if (amount <= 1000) {
            std::cout << "Manager approved $" << amount << std::endl;
        } else if (successor) {
            successor->approveRequest(amount); // 转发请求
        }
    }
};

// 具体处理者：总监
class Director : public Approver {
public:
    void approveRequest(double amount) override {
        if (amount <= 5000) {
            std::cout << "Director approved $" << amount << std::endl;
        } else if (successor) {
            successor->approveRequest(amount); // 转发请求
        }
    }
};

// 具体处理者：董事
class VicePresident : public Approver {
public:
    void approveRequest(double amount) override {
        if (amount <= 10000) {
            std::cout << "VicePresident approved $" << amount << std::endl;
        } else {
            std::cout << "Request $" << amount << " requires an executive meeting!" << std::endl;
        }
    }
};

// 客户端代码
int main() {
    Manager* manager = new Manager();
    Director* director = new Director();
    VicePresident* vp = new VicePresident();

    // 构建责任链
    manager->setSuccessor(director);
    director->setSuccessor(vp);

    // 发送请求
    manager->approveRequest(500);    // 经理处理
    manager->approveRequest(1500);   // 转发到总监处理
    manager->approveRequest(6000);   // 转发到副总裁处理
    manager->approveRequest(12000);  // 超过所有处理者的能力

    // 清理内存
    delete manager;
    delete director;
    delete vp;

    return 0;
}
```

说明

1. 抽象处理者：`Approver` 定义了处理请求的接口，并持有下一个处理者的引用。
2. 具体处理者：
   - `Manager`：可以处理不超过1000的请求，如无法处理则传递给下一个处理者。
   - `Director`：可以处理不超过5000的请求，以此类推。
   - `VicePresident`：处理不超过10000的请求，超出范围则提示需要召开高管会议。
3. 客户端：构建责任链并发送不同金额的请求，展示责任链的工作流程。

优点

- 解耦：请求的发送者和接收者之间解耦，增强了系统的灵活性。
- 灵活性：可以动态添加或修改处理者。
- 职责分离：将请求处理逻辑分散到多个处理者中，符合单一职责原则。

适用场景

- 当一个请求可以由多个对象处理，但具体处理者不固定时。
- 处理请求的责任可以根据不同情况动态改变。
- 希望将请求的发送者与接收者解耦的场合。

责任链模式通过将请求沿着处理链传递，有效地管理了多个处理者之间的协作，提升系统的灵活性和可扩展性。

#### 命令

命令模式是一种行为型设计模式，它将请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化、排队请求、记录日志，以及支持可撤销操作。命令模式主要分为四个部分：命令接口、具体命令、接收者和调用者。

主要组成部分

1. 命令接口（Command）：声明执行命令的接口。
2. 具体命令（Concrete Command）：实现命令接口，定义与接收者之间的绑定，并调用接收者的相应操作。
3. 接收者（Receiver）：知道如何实现与执行相关的操作，其实就是执行实际的业务逻辑。
4. 调用者（Invoker）：调用命令，并在适当的情况下执行它。

例子

以下是使用命令模式的示例，展示如何实现一个简单的遥控器，通过它来控制灯的打开和关闭。

示例：

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 命令接口
class Command {
public:
    virtual void execute() = 0; // 执行命令
    virtual ~Command() = default;
};

// 接收者：灯
class Light {
public:
    void turnOn() {
        std::cout << "The light is ON" << std::endl;
    }

    void turnOff() {
        std::cout << "The light is OFF" << std::endl;
    }
};

// 具体命令：打开灯
class TurnOnLightCommand : public Command {
private:
    Light* light;

public:
    TurnOnLightCommand(Light* light) : light(light) {}

    void execute() override {
        light->turnOn();
    }
};

// 具体命令：关闭灯
class TurnOffLightCommand : public Command {
private:
    Light* light;

public:
    TurnOffLightCommand(Light* light) : light(light) {}

    void execute() override {
        light->turnOff();
    }
};

// 调用者：遥控器
class RemoteControl {
private:
    std::unique_ptr<Command> command;

public:
    void setCommand(Command* cmd) {
        command.reset(cmd);
    }

    void pressButton() {
        if (command) {
            command->execute();
        }
    }
};

// 客户端代码
int main() {
    Light* light = new Light();

    TurnOnLightCommand* turnOn = new TurnOnLightCommand(light);
    TurnOffLightCommand* turnOff = new TurnOffLightCommand(light);

    RemoteControl remote;

    remote.setCommand(turnOn);
    remote.pressButton(); // 打开灯
    std::cout << std::endl;

    remote.setCommand(turnOff);
    remote.pressButton(); // 关闭灯

    // 清理内存
    delete turnOn;
    delete turnOff;
    delete light;

    return 0;
}
```

说明

1. 命令接口：`Command` 定义了通用的 `execute()` 方法，所有命令类都要实现这个方法。
2. 接收者 (`Light`)：具体执行某个操作（如开灯和关灯）的类。
3. 具体命令：
   - `TurnOnLightCommand`：负责打开灯的命令，调用灯的 `turnOn` 方法。
   - `TurnOffLightCommand`：负责关闭灯的命令，调用灯的 `turnOff` 方法。
4. 调用者 (`RemoteControl`)：持有一个命令，并在调用 `pressButton()` 方法时执行命令。
5. 客户端：创建遥控器和命令对象，并通过遥控器发出命令。

优点

- 解耦：请求的发送者与接收者之间解耦。
- 参数化：可以将请求参数化，支持不同的命令组合。
- 支持撤销与重做：可以很容易地实现撤销和重做操作，通过记录命令历史。

适用场景

- 为一个操作请求构建一个对象，以便可以以不同的方式对其进行管理。
- 支持撤销操作的场景。
- 需要将请求排队或记录请求日志。

命令模式通过将请求封装成对象，增强了系统的灵活性和可扩展性，适合用于各种需要控制操作的场景。

#### 迭代器模式

迭代器模式是一种行为型设计模式，允许顺序访问一个聚合对象（集合）中的元素，而不暴露该对象的内部结构。这个模式非常适用于需要遍历集合对象中的元素的场景。

主要组成部分

1. 迭代器接口（Iterator）：定义访问和遍历元素的接口。
2. 具体迭代器（Concrete Iterator）：实现迭代器接口，维护对聚合对象的引用，并实现迭代器的遍历逻辑。
3. 聚合接口（Aggregate）：定义创建迭代器的方法。
4. 具体聚合（Concrete Aggregate）：实现聚合接口，返回相应的具体迭代器。

例子

以下是一个简单的迭代器模式示例，用于遍历 `BookCollection`（书籍集合）中的书籍。

示例：

```cpp
#include <iostream>
#include <vector>
#include <string>

// 迭代器接口
class Iterator {
public:
    virtual bool hasNext() = 0; // 判断是否还有下一个元素
    virtual std::string next() = 0; // 返回下一个元素
    virtual ~Iterator() = default;
};

// 聚合接口
class Aggregate {
public:
    virtual Iterator* createIterator() = 0; // 创建迭代器
    virtual ~Aggregate() = default;
};

// 具体聚合：书籍集合
class BookCollection : public Aggregate {
private:
    std::vector<std::string> books;

public:
    void addBook(const std::string& book) {
        books.push_back(book);
    }

    std::string getBook(int index) {
        return books.at(index);
    }

    int getSize() {
        return books.size();
    }

    Iterator* createIterator() override;
};

// 具体迭代器：书籍迭代器
class BookIterator : public Iterator {
private:
    BookCollection* collection;
    int index;

public:
    BookIterator(BookCollection* collection) : collection(collection), index(0) {}

    bool hasNext() override {
        return index < collection->getSize();
    }

    std::string next() override {
        return collection->getBook(index++);
    }
};

// 创建 BookCollection 的迭代器
Iterator* BookCollection::createIterator() {
    return new BookIterator(this);
}

// 客户端代码
int main() {
    BookCollection collection;
    collection.addBook("C++ Primer");
    collection.addBook("Effective C++");
    collection.addBook("Design Patterns");

    Iterator* iterator = collection.createIterator();

    while (iterator->hasNext()) {
        std::string book = iterator->next();
        std::cout << book << std::endl;
    }

    delete iterator; // 清理内存

    return 0;
}
```

说明

1. 迭代器接口：`Iterator` 定义了 `hasNext()` 和 `next()` 方法，用于遍历集合。
2. 聚合接口：`Aggregate` 定义了创建迭代器的方法。
3. 具体聚合：`BookCollection` 意味着书籍的集合，包含书籍的添加和获取方法。
4. 具体迭代器：`BookIterator` 实现迭代器接口，用于遍历 `BookCollection` 中的书籍，维护当前索引。
5. 客户端：创建 `BookCollection` 对象，并通过迭代器遍历所有书籍。

优点

- 分离遍历和聚合：客户端和聚合对象解耦，客户端不需要了解聚合对象的具体实现。
- 支持多种遍历方式：可以为同一聚合对象提供多种迭代器。
- 简化了客户端代码：客户端只关心遍历接口，使用起来更为简单。

适用场景

- 需要访问一个集合中的元素，不需要暴露集合的内部结构。
- 希望创建各种不同的迭代器，来支持不同的遍历需求。

迭代器模式提供了一种灵活而一致的方式来访问集合中的元素，加强代码的可维护性和扩展性。

#### 备忘录

备忘录模式是一种行为型设计模式，用于在不违反封装的情况下，捕获对象的内部状态，以便在未来能够恢复该状态。这个模式是为了实现对象的状态回滚，非常适合需要存储和恢复操作历史的场景。

主要组成部分

1. 备忘录（Memento）：存储对象的内部状态。
2. 发起人（Originator）：需要保存和恢复状态的对象。
3. 管理者（Caretaker）：负责备忘录的管理，保存和恢复发起人的状态。

例子

以下是一个简单的备忘录模式示例，用于展示文本编辑器的状态恢复。

示例：

```cpp
#include <iostream>
#include <string>
#include <vector>

// 备忘录类
class Memento {
public:
    explicit Memento(const std::string& state) : state(state) {}
    
    std::string getState() const {
        return state;
    }
private:
    std::string state; // 保存的状态
};

// 发起人类
class Originator {
public:
    void setState(const std::string& state) {
        this->state = state;
        std::cout << "状态设置为: " << state << std::endl;
    }

    Memento* saveStateToMemento() {
        return new Memento(state); // 创建备忘录
    }

    void getStateFromMemento(Memento* memento) {
        state = memento->getState(); // 从备忘录恢复状态
        std::cout << "状态恢复为: " << state << std::endl;
    }

private:
    std::string state; // 内部状态
};

// 管理者类
class Caretaker {
public:
    void save(Originator* originator) {
        mementos.push_back(originator->saveStateToMemento()); // 保存发起人的状态
    }

    void undo(Originator* originator) {
        if (!mementos.empty()) {
            originator->getStateFromMemento(mementos.back()); // 恢复发起人的状态
            mementos.pop_back(); // 移除最后一个备忘录
        } else {
            std::cout << "没有可以恢复的状态。" << std::endl;
        }
    }

private:
    std::vector<Memento*> mementos; // 储存备忘录的集合
};

// 客户端代码
int main() {
    Originator originator;
    Caretaker caretaker;

    originator.setState("状态1");
    caretaker.save(&originator);

    originator.setState("状态2");
    caretaker.save(&originator);

    originator.setState("状态3");
    
    // 恢复到之前的状态
    caretaker.undo(&originator); // 恢复到 "状态2"
    caretaker.undo(&originator); // 恢复到 "状态1"
    caretaker.undo(&originator); // 尝试恢复之前的状态，应该提示没有可恢复状态

    return 0;
}
```

说明

1. 备忘录类：`Memento` 保存了发起人的状态，通过 `getState` 方法可以获取状态。
2. 发起人类：`Originator` 维护一个内部状态，能够创建和恢复备忘录。
3. 管理者类：`Caretaker` 负责保存和管理多个备忘录，提供保存和恢复的接口。
4. 客户端：演示了如何设置状态、保存状态，以及如何恢复到之前的状态。

优点

- 封装性：状态被封装在备忘录中，发起人不需要暴露内部实现。
- 简化状态恢复：通过备忘录管理器，可以轻松实现状态的保存和恢复。

适用场景

- 需要提供操作历史记录的功能，例如文本编辑器等。
- 需要实现撤销操作的场景。
- 需要保存和恢复对象的复杂状态。

备忘录模式通过提供一个简洁的方法来保存对象的状态，增强了程序的灵活性和可维护性。

#### 观察者

观察者模式是一种行为型设计模式，用于定义一对多的依赖关系，允许一个对象（主题）在其状态发生变化时，自动通知所有依赖于它的对象（观察者）。这种模式常用于实现事件驱动的系统。

主要组成部分

1. 主题（Subject）：管理观察者的注册、注销和通知操作。
2. 观察者（Observer）：定义一个更新接口，以便在主题状态改变时接收通知。
3. 具体主题（Concrete Subject）：实现主题接口，维护状态并向观察者发送通知。
4. 具体观察者（Concrete Observer）：实现观察者接口，以便在收到通知时执行相应的操作。

例子

以下是一个简单的观察者模式示例，模拟一个天气站，天气状态的变化会通知多个显示设备。

示例：

```cpp
#include <iostream>
#include <vector>
#include <string>

// 观察者接口
class Observer {
public:
    virtual void update(float temperature, float humidity) = 0;
    virtual ~Observer() = default;
};

// 主题接口
class Subject {
public:
    virtual void registerObserver(Observer* observer) = 0;
    virtual void removeObserver(Observer* observer) = 0;
    virtual void notifyObservers() = 0;
    virtual ~Subject() = default;
};

// 具体主题：天气数据
class WeatherData : public Subject {
private:
    std::vector<Observer*> observers;
    float temperature;
    float humidity;

public:
    void registerObserver(Observer* observer) override {
        observers.push_back(observer);
    }

    void removeObserver(Observer* observer) override {
        observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
    }

    void notifyObservers() override {
        for (auto observer : observers) {
            observer->update(temperature, humidity);
        }
    }

    void setMeasurements(float temp, float hum) {
        temperature = temp;
        humidity = hum;
        notifyObservers(); // 状态改变时通知观察者
    }
};

// 具体观察者：显示当前天气条件
class CurrentConditionsDisplay : public Observer {
private:
    float temperature;
    float humidity;

public:
    void update(float temp, float hum) override {
        temperature = temp;
        humidity = hum;
        display();
    }

    void display() {
        std::cout << "当前气温: " << temperature << "°C, 湿度: " << humidity << "%" << std::endl;
    }
};

// 客户端代码
int main() {
    WeatherData weatherData;

    CurrentConditionsDisplay currentDisplay;
    weatherData.registerObserver(&currentDisplay); // 注册观察者

    // 更新天气数据，观察者会收到通知
    weatherData.setMeasurements(25.5, 65);
    weatherData.setMeasurements(30.0, 70);

    return 0;
}
```

说明

1. 观察者接口：`Observer` 定义了 `update` 方法，当主题状态变化时被调用。
2. 主题接口：`Subject` 定义了注册、注销和通知观察者的方法。
3. 具体主题：`WeatherData` 类实现了主题接口，存储观察者并在气象数据变化时通知他们。
4. 具体观察者：`CurrentConditionsDisplay` 类实现了观察者接口，接收天气数据更新并显示。
5. 客户端：在 `main` 函数中，创建 `WeatherData` 和 `CurrentConditionsDisplay`，观察者注册后，状态变化时自动通知观察者。

优点

- 松耦合：主题和观察者之间的依赖关系是松散的，便于扩展和维护。
- 动态增加或删除观察者：可以在运行时方便地添加或删除观察者。

适用场景

- 需要在状态变化时自动通知多个对象的场景，例如事件监听、消息推送等。
- 实现 MVC 模式中的模型和视图之间的交互。

#### 状态

状态模式是一种行为型设计模式，允许对象在其内部状态改变时改变其行为。换句话说，状态模式使一个对象看起来像是改变了其类。状态模式特别适合处理对象在不同状态下的不同行为，简化了对象的条件逻辑。

主要组成部分

1. 上下文（Context）：定义一个客户感兴趣的接口，并保存一个具体状态的引用。
2. 状态接口（State）：定义一个接口，以封装与上下文的一个特定状态相关的行为。
3. 具体状态（Concrete State）：实现状态接口，具体的状态行为。

例子

下面的示例展示了一个简单的工作流管理系统，其中包含“待处理”、“处理中”和“已完成”三种状态。

示例：

```cpp
#include <iostream>
#include <memory>

// 前向声明
class Task;

// 状态接口
class State {
public:
    virtual void handle(Task* task) = 0;
    virtual ~State() = default;
};

// 上下文类
class Task {
private:
    std::unique_ptr<State> currentState;

public:
    Task(std::unique_ptr<State> initialState) : currentState(std::move(initialState)) {}

    void setState(std::unique_ptr<State> state) {
        currentState = std::move(state);
    }

    void handle() {
        currentState->handle(this);
    }
};

// 具体状态：待处理状态
class PendingState : public State {
public:
    void handle(Task* task) override {
        std::cout << "任务在待处理状态中，正在转换为处理中..." << std::endl;
        task->setState(std::make_unique<ProcessingState>());
    }
};

// 具体状态：处理中状态
class ProcessingState : public State {
public:
    void handle(Task* task) override {
        std::cout << "任务正在处理，处理完成，将转为已完成状态..." << std::endl;
        task->setState(std::make_unique<CompletedState>());
    }
};

// 具体状态：已完成状态
class CompletedState : public State {
public:
    void handle(Task* task) override {
        std::cout << "任务已完成，无法再处理。" << std::endl;
    }
};

// 客户端代码
int main() {
    // 创建一个初始状态为待处理的任务
    Task task(std::make_unique<PendingState>());

    // 处理任务，状态将依次转换
    task.handle(); // 待处理 -> 处理中
    task.handle(); // 处理中 -> 已完成
    task.handle(); // 已完成，无法再处理

    return 0;
}
```

说明

1. 状态接口：`State` 定义了一个接口，包含处理状态的方法 `handle`。
2. 上下文类：`Task` 类维护一个当前状态，并根据状态的行为执行操作。
3. 具体状态：
   - `PendingState`：表示待处理状态，调用 `handle` 时转换到 `ProcessingState`。
   - `ProcessingState`：表示处理中状态，调用 `handle` 时转换到 `CompletedState`。
   - `CompletedState`：表示已完成状态，调用 `handle` 时不再做任何转换。
4. 客户端：在 `main` 函数中，初始化任务为待处理状态，并依次调用 `handle`，状态将在三个状态间转换。

优点

- 简化状态管理：将状态相关的行为分散到不同的状态类中，避免复杂的条件语句。
- 易于扩展：添加新状态只需创建新类，而无需修改现有代码。
- 封装变化：每个状态的行为封装在状态类中，更符合单一职责原则。

适用场景

- 对象的行为依赖于其状态，并且可以在运行时改变状态。
- 有多个状态会导致大量的条件判断，适合使用状态模式来替代复杂的条件逻辑。

状态模式通过将状态和行为解耦，使得状态管理更加直观和灵活，提升了代码的可读性和可维护性。

#### 策略

策略模式是一种行为型设计模式，定义了一系列算法，将每个算法封装起来，并使它们可以互换。策略模式使得算法独立于使用它的客户端，可以在运行时选择或更改算法。

主要组成部分

1. 策略接口（Strategy）：定义一个算法的公共接口。
2. 具体策略（Concrete Strategy）：实现策略接口的具体算法。
3. 上下文（Context）：持有一个策略的引用，定义了一个接口来允许客户端使用策略。

例子

下面的示例展示了一个简单的支付系统，可以选择不同的支付方式，如“信用卡支付”、“支付宝支付”和“现金支付”。

示例：

```cpp
#include <iostream>
#include <memory>

// 策略接口
class PaymentStrategy {
public:
    virtual void pay(int amount) = 0;
    virtual ~PaymentStrategy() = default;
};

// 具体策略：信用卡支付
class CreditCardPayment : public PaymentStrategy {
public:
    void pay(int amount) override {
        std::cout << "使用信用卡支付：" << amount << " 元。" << std::endl;
    }
};

// 具体策略：支付宝支付
class AlipayPayment : public PaymentStrategy {
public:
    void pay(int amount) override {
        std::cout << "使用支付宝支付：" << amount << " 元。" << std::endl;
    }
};

// 具体策略：现金支付
class CashPayment : public PaymentStrategy {
public:
    void pay(int amount) override {
        std::cout << "使用现金支付：" << amount << " 元。" << std::endl;
    }
};

// 上下文类
class ShoppingCart {
private:
    std::unique_ptr<PaymentStrategy> paymentStrategy;

public:
    void setPaymentStrategy(std::unique_ptr<PaymentStrategy> strategy) {
        paymentStrategy = std::move(strategy);
    }

    void checkout(int amount) {
        if (paymentStrategy) {
            paymentStrategy->pay(amount);
        } else {
            std::cout << "错误：未选择支付方式。" << std::endl;
        }
    }
};

// 客户端代码
int main() {
    ShoppingCart cart;

    // 使用信用卡支付
    cart.setPaymentStrategy(std::make_unique<CreditCardPayment>());
    cart.checkout(100);

    // 使用支付宝支付
    cart.setPaymentStrategy(std::make_unique<AlipayPayment>());
    cart.checkout(200);

    // 使用现金支付
    cart.setPaymentStrategy(std::make_unique<CashPayment>());
    cart.checkout(300);

    return 0;
}
```

说明

1. 策略接口：`PaymentStrategy` 定义了 `pay` 方法，所有具体支付方式都需要实现这个方法。
2. 具体策略：`CreditCardPayment`、`AlipayPayment` 和 `CashPayment` 都实现了 `PaymentStrategy` 接口，提供了具体的支付方式逻辑。
3. 上下文类：`ShoppingCart` 持有一个支付策略的实例，允许客户端设置不同的支付方式，并在结账时使用所选的支付策略。
4. 客户端：在 `main` 函数中，我们可以简单地设置不同的支付方式，并调用 `checkout` 方法进行支付。

优点

- 算法独立：将算法与使用它的代码分离，降低了耦合。
- 易于扩展：可以通过增加新的策略类来轻松扩展功能，而无需修改现有代码。
- 简化代码：避免了大量的条件语句，使代码更清晰易懂。

适用场景

- 在不同的上下文中需要采用不同算法的情况。
- 当有多个相似的类仅在行为上有所不同，适合使用策略模式来避免重复代码。
- 需要动态选择行为时，策略模式提供了灵活性和可扩展性。

策略模式提升了代码的可维护性和灵活性，使得通过组合不同策略来实现多样化的行为变得简单。

#### 模板方法

模板方法模式是一种行为型设计模式，定义了一个算法的骨架（模板），将一些步骤延迟到子类中。这样子类可以在不改变算法结构的情况下重定义某些特定步骤。

主要组成部分

1. 抽象类（Abstract Class）：定义了模板方法和基本的步骤。
2. 具体类（Concrete Class）：实现抽象类中的步骤，提供特定的实现。

例子

下面的示例展示了一个报表生成的过程，其中不同类型的报表通过共用模板方法来控制生成的流程。

示例：

```cpp
#include <iostream>

// 抽象类
class Report {
public:
    // 模板方法
    void generateReport() {
        collectData();
        formatReport();
        printReport();
    }

protected:
    // 这些方法会在子类中实现
    virtual void collectData() = 0;
    virtual void formatReport() = 0;

private:
    void printReport() {
        std::cout << "打印报告..." << std::endl;
    }
};

// 具体类：销售报告
class SalesReport : public Report {
protected:
    void collectData() override {
        std::cout << "收集销售数据..." << std::endl;
    }

    void formatReport() override {
        std::cout << "格式化销售报告..." << std::endl;
    }
};

// 具体类：人事报告
class HRReport : public Report {
protected:
    void collectData() override {
        std::cout << "收集人事数据..." << std::endl;
    }

    void formatReport() override {
        std::cout << "格式化人事报告..." << std::endl;
    }
};

// 客户端代码
int main() {
    Report* sales = new SalesReport();
    sales->generateReport();

    std::cout << std::endl;

    Report* hr = new HRReport();
    hr->generateReport();

    // 清理资源
    delete sales;
    delete hr;

    return 0;
}
```

说明

1. 抽象类：`Report` 定义了模板方法 `generateReport`，该方法中包括了收集数据、格式化报告和打印报告的步骤。`collectData` 和 `formatReport` 是抽象方法，子类需要实现。
2. 具体类：
   - `SalesReport` 实现了 `collectData` 和 `formatReport` 方法，提供具体的销售数据收集和报告格式化逻辑。
   - `HRReport` 同样实现了这些方法，提供人事数据收集和格式化逻辑。
3. 客户端：在 `main` 函数中，创建了不同类型的报告对象，并调用 `generateReport` 方法，这将按照模板方法的定义顺序执行。

优点

- 复用代码：将算法的公共部分提取到基类中，避免重复代码。
- 控制算法结构：模板方法定义了算法的整体结构，而具体步骤由子类实现，允许子类自由扩展。
- 易于维护：算法的修改只需在基类中进行，而具体实现保持不变。

适用场景

- 当多个类有共同行为的骨架，但在某些步骤存在差异时。
- 希望定义一个算法的框架，而将具体的实现延迟到子类中。
- 需要控制步骤的执行顺序，并希望子类能够扩展或替换某些步骤的实现。

#### 访问者

访问者模式是一种行为型设计模式，允许你在不改变被访问对象的类的情况下，向这些对象添加新的操作。通过将操作与对象结构分离，访问者模式使得在不修改对象的情况下，增加对对象的处理的能力。

主要组成部分

1. 访问者接口（Visitor Interface）：定义对每个元素的访问方法。
2. 具体访问者（Concrete Visitor）：实现访问者接口并定义具体操作。
3. 抽象元素（Element Interface）：定义接受访问者的方法。
4. 具体元素（Concrete Element）：实现抽象元素接口，接收访问者。

例子

下面的示例展示了一个元素结构，其中可以是不同类型的形状（如圆形和矩形），并且可以通过访问者计算它们的面积和周长。

示例：

```cpp
#include <iostream>
#include <vector>
#include <memory>

// 前向声明访问者
class ShapeVisitor;

// 抽象元素接口
class Shape {
public:
    virtual void accept(ShapeVisitor &visitor) = 0; // 接受访问者
    virtual ~Shape() = default;
};

// 具体元素：圆形
class Circle : public Shape {
public:
    Circle(double r) : radius(r) {}
    
    double getRadius() const { return radius; }

    void accept(ShapeVisitor &visitor) override;

private:
    double radius;
};

// 具体元素：矩形
class Rectangle : public Shape {
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    double getWidth() const { return width; }
    double getHeight() const { return height; }

    void accept(ShapeVisitor &visitor) override;

private:
    double width, height;
};

// 访问者接口
class ShapeVisitor {
public:
    virtual void visit(Circle &circle) = 0;
    virtual void visit(Rectangle &rectangle) = 0;
    virtual ~ShapeVisitor() = default;
};

// 具体访问者：计算面积
class AreaVisitor : public ShapeVisitor {
public:
    void visit(Circle &circle) override {
        double area = 3.14159 * circle.getRadius() * circle.getRadius();
        std::cout << "圆的面积: " << area << std::endl;
    }

    void visit(Rectangle &rectangle) override {
        double area = rectangle.getWidth() * rectangle.getHeight();
        std::cout << "矩形的面积: " << area << std::endl;
    }
};

// 具体访问者：计算周长
class PerimeterVisitor : public ShapeVisitor {
public:
    void visit(Circle &circle) override {
        double perimeter = 2 * 3.14159 * circle.getRadius();
        std::cout << "圆的周长: " << perimeter << std::endl;
    }

    void visit(Rectangle &rectangle) override {
        double perimeter = 2 * (rectangle.getWidth() + rectangle.getHeight());
        std::cout << "矩形的周长: " << perimeter << std::endl;
    }
};

// 方法实现：接受访问者
void Circle::accept(ShapeVisitor &visitor) {
    visitor.visit(*this);
}

void Rectangle::accept(ShapeVisitor &visitor) {
    visitor.visit(*this);
}

// 客户端代码
int main() {
    std::vector<std::unique_ptr<Shape>> shapes;
    shapes.push_back(std::make_unique<Circle>(5.0));
    shapes.push_back(std::make_unique<Rectangle>(4.0, 6.0));

    AreaVisitor areaVisitor;
    PerimeterVisitor perimeterVisitor;

    std::cout << "计算面积:" << std::endl;
    for (auto &shape : shapes) {
        shape->accept(areaVisitor);
    }

    std::cout << "\n计算周长:" << std::endl;
    for (auto &shape : shapes) {
        shape->accept(perimeterVisitor);
    }

    return 0;
}
```

说明

1. 抽象元素接口：`Shape` 定义了 `accept` 方法，允许访问者访问具体元素。
2. 具体元素：
   - `Circle` 和 `Rectangle` 实现了 `Shape` 接口，并提供了各自的 `accept` 方法。
3. 访问者接口：`ShapeVisitor` 定义了访问不同形状的方法。
4. 具体访问者：
   - `AreaVisitor` 实现了计算面积的逻辑。
   - `PerimeterVisitor` 实现了计算周长的逻辑。
5. 客户端：在 `main` 函数中，创建了不同类型的形状，并使用不同的访问者计算它们的面积和周长。

优点

- 扩展性：可以在不修改现有元素的情况下增加新的操作。
- 分离关注点：将操作与元素结构分离，符合单一职责原则。
- 易于维护：新操作的增加不需要影响现有的元素类。

适用场景

- 当需要对一个对象结构中的众多对象进行不同的操作时。
- 当需要在不修改对象的类的情况下，添加新操作时。
- 当对象结构相对稳定，但是操作经常变化时。

访问者模式简化了对象的操作逻辑，使得对对象集合的多种操作变得灵活而可维护。





